[{"title":"","date":"2018-04-07T07:01:04.436Z","path":"2018/04/07/工作中遇到的 git 命令/","text":"工作中遇到的 git 命令标签（空格分隔）： git 2018年4月2日情景： 今天早上使用 git pull 命令拉取了最新代码，由于提前没有执行 git log 查看日志，结果上次的提交代码只能在生产环境运行，启动项目报错 W(￣_￣)W 处理只要撤销刚才的 git pull 就可以了 首先使用 git log 查看提交日志12345678June@DESKTOP-2DT17LG MINGW64 /d/smartdotDevStudio/zye/las-jdjr (develop)$ git logcommit 320aa631e3964f4039e6f86792f0405793794a01Author: yangbin &lt;yangbin@smartdot.com&gt;Date: Sun Apr 1 22:02:34 2018 +0800 类型和待办修改...... 使用 git reflog 查看之前的操作日志12345678910$ git reflog320aa63 HEAD@&#123;0&#125;: pull: Fast-forwardd1f8b3e HEAD@&#123;1&#125;: commit: 修改审批单-增加用印份数，履行期限的显示1b3cc7a HEAD@&#123;2&#125;: commit: 合同审批单加入各环节审批意见2118c3d HEAD@&#123;3&#125;: pull: Fast-forwardb0a8a2d HEAD@&#123;4&#125;: pull: Merge made by the &apos;recursive&apos; strategy.8686d43 HEAD@&#123;5&#125;: commit: 修复签订打开为空白页面bug418c75d HEAD@&#123;6&#125;: commit: 修改下载审批单带条形码0bbdbff HEAD@&#123;7&#125;: checkout: moving from master to develop350acfb HEAD@&#123;8&#125;: clone: from http://172.20.90.141/las-project/las-jdjr.git 然后使用 git reset –hard HEAD@{n} ,（n 是你要退回的引用位置）回退12$ git reset --hard HEAD@&#123;1&#125;HEAD is now at d1f8b3e 修改审批单-增加用印份数，履行期限的显示 再次查看日志1234567June@DESKTOP-2DT17LG MINGW64 /d/smartdotDevStudio/zye/las-jdjr (develop)$ git logcommit d1f8b3e00e0dad17aa7fee6bf97ba4fe244d33bbAuthor: JUNE &lt;june929546724@gmail.com&gt;Date: Sat Mar 31 19:37:47 2018 +0800 修改审批单-增加用印份数，履行期限的显示 成功退回 pull 之前的提交版本 (＾－＾)V","tags":[]},{"title":"Service初步总结","date":"2017-05-21T01:23:32.466Z","path":"2017/05/21/Service初步总结/","text":"Service 是实现程序后台运行的解决方案，Service 并不是运行在单独的进程中的，而是依赖于创建 Service 时所在的应用程序进程。当某个应用程序进程被杀掉时，所有依赖于该进程的 Service 也会停止运行。服务默认是运行在主线程中的，所以需要我们在 Service 内部手动创建子线程来执行具体的任务。 Service 的基本用法1. 定义一个Service定义一个 Service，直接继承 Service 即可，在子类中实现 onBind() 方法，其内部还有 onCreate() 方法、onStartCommand() 方法、onDestroy() 方法。分别在 Service 被创建时、被启动时、被销毁时调用。 1234567public class MyService extends Service &#123;@Override public IBinder onBind(Intent intent) &#123; return null; &#125;&#125; 2. 启动和停止Service在 MainActivity 中借助 Intent 来启动和停止 Service 。对于 Service 来说：如果是第一次启动则调用方法顺序为 onCreate() –&gt; onStartCommand()如果已经启动一次则调用方法的顺序为 onStartCommand()12345678910111213@Overridepublic void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.startService: Intent startIntent = new Intent(this, MyService.class); startService(startIntent); break; case R.id.stopService: Intent stopIntent = new Intent(this, MyService.class); stopService(stopIntent); break; &#125;&#125; Activity 和 Service 进行通信Activity 和 Service 之间的通信，其实也就是给 Activity 绑定 Service，具体如下：123456789101112131415161718public class MyService extends Service &#123; private DownloadBinder mBinder = new DownloadBinder(); // 具体的功能类 class DownloadBinder extends Binder &#123; public void startDownload() &#123; Log.d(TAG, \"startDownload()\"); &#125; public int getProgress() &#123; Log.d(TAG, \"getProgress()\"); return 8; &#125; &#125; @Override public IBinder onBind(Intent intent) &#123; return mBinder; &#125;&#125; 在 Activity 中，创建 ServiceConnection 匿名类，重写 onServiceConnected() 方法和 onServiceDisconnected() 方法，这两个方法分别在 Activity 和 Service 成功绑定以及解除绑定的时候调用。123456789101112131415161718192021222324252627282930313233343536373839404142434445public class MainActivity extends AppCompatActivity implements View.OnClickListener&#123; private MyService.DownloadBinder downloadBinder; private ServiceConnection connection=new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; downloadBinder = (MyService.DownloadBinder) service; downloadBinder.startDownload(); downloadBinder.getProgress(); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; &#125;&#125;; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Button bindService = (Button) findViewById(R.id.bindService); Button unbindService = (Button) findViewById(R.id.UnbindService); bindService.setOnClickListener(this); unbindService.setOnClickListener(this); &#125; @Override public void onClick(View v) &#123; switch (v.getId()) &#123; case R.id.bindService: Intent bindIntent = new Intent(this, MyService.class); bindService(bindIntent, connection, BIND_AUTO_CREATE); break; case R.id.UnbindService: unbindService(connection); break; default: break; &#125; &#125;&#125; Service的生命周期如图所示为 Service的生命周期，对于非绑定 Service 的生命周期为：onCreate() –&gt; onStartCommand() –&gt; onDestroy() 对于绑定 Service 的生命周期为：onCreate() –&gt; onBind() –&gt; onUnbind() –&gt; onDestroy() 前台服务构建一个 Notification 对象，调用 StartForeground() 方法即可将 Service变成一个前台服务，显示在系统状态栏。 在 Service 子类的 onCreate() 方法中123456789101112131415@Overridepublic void onCreate() &#123; super.onCreate(); Intent intent = new Intent(this, MainActivity.class); PendingIntent pi = PendingIntent.getActivity(this, 0, intent, 0); Notification notification = new NotificationCompat.Builder(this) .setContentTitle(\"前台服务\") .setContentText(\"这是一个前台服务\") .setWhen(System.currentTimeMillis()) .setSmallIcon(R.mipmap.ic_launcher_round) .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher_round)) .setContentIntent(pi) .build(); startForeground(1, notification);&#125; IntentServiceIntentService 和 Service 的区别在于，IntentService 重新开启了一个子线程在 Service 中执行耗时操作，并且在线程执行完后会自动调用 onDestroy() 方法，来停止 Service12345678910111213141516public class MyIntentService extends IntentService &#123; public MyIntentService() &#123; super(\"MyIntentService\"); &#125; @Override protected void onHandleIntent(@Nullable Intent intent) &#123; Log.d(\"Service\", \"IntentService Thread id is \" + Thread.currentThread().getId()); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d(\"Service\", \"IntentService onDestroy()\"); &#125;&#125;","tags":[{"name":"Service","slug":"Service","permalink":"http://yoursite.com/tags/Service/"}]},{"title":"Android多线程编程","date":"2017-05-21T01:23:19.841Z","path":"2017/05/21/Android多线程编程/","text":"异步消息处理机制对于 Android 的多线程来说，和 Java 中的多线程一样有两种基本的用法，分别是继承 Thread 和 实现 Runnable 类。但是对于 Android，有自己的异步纤细处理机制，它由四个部分组成， Message、Handler、MessageQueue 和 Looper1. Message 是在线程之间传递的消息，可以携带少量信息2. Handler 主要是用于发送和处理消息的，发送使用 sendMessage()方法，处理消息使用 handleMessage()方法3. MessageQueue 是消息队列，主要存放 Handler 发送的消息4. Looper 用来管理 MessageQueue 注意： 每个线程只有一个 Looper 对象，每个Looper只有一个 MessageQueue，每个 MessageQueue 有 N 个 Message，每个 Message 最多指定一个 Handler 来处理 Handler(N)：Looper(1)：MessageQueue(1)：Thread(1) 使用异步消息处理机制来更新 UI123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity &#123; public static final int UPDATE_TEXT = 1; TextView text; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); text = (TextView) findViewById(R.id.change_text); &#125; // 在Handler中处理子线程发送来的消息 Handler handler = new Handler() &#123; @Override public void handleMessage(Message msg)&#123; switch(msg.what)&#123; case UPDATE_TEXT: text.setText(\"Nice to meet you\"); break; &#125; &#125; &#125; //在子线程中发送消息 public void changeText(View v)&#123; new Thread(new Runnable()&#123; Message msg = new Message(); msg.what = UPDATE_TEXT; handler.sendMessage(msg); &#125;).start(); &#125;&#125; AsyncTaskAsyncTask 是 Android 专门提供的用于在子线程中对UI的操作，AsyncTask 是一个抽象类需要被子类继承，它指定了三个泛型参数如下：1. Params 执行 AsyncTask 时传入参数，用于在后台任务中使用2. Progress 后台执行任务的进度单位3. Result 后台执行完后返回结果的类型123class DownloadTask extends AysncTask&lt;Void, Integer, Boolean&gt; &#123; ...&#125; 使用 AysncTask 需要重写的方法 1. onPreExecute()在后台任务开始前被调用，用于一些界面的初始化操作。2. doInBackground(Params…)这个方法所有代码都会在子线程中运行，处理耗时操作，更新 UI 操作，则在其内部使用 publishProgress(Progress…) 方法来完成。3. onProgressUpdate(Progress…)当调用 publishProgress(Progress…) 方法后，这个方法也被调用，在其中可以进行对 UI 进行操作4. onPostExecute(Result)当 doInBackground(Params…) 执行 return 语句时被调用，根据返回结果来处理 UI 操作。1234567891011121314151617181920212223242526272829303132333435363738394041public class DownloadTask extends AsyncTask&lt;String, Integer, Integer&gt; &#123; // 执行界面初始化 protected void onPreExcute() &#123; prgressDialog.show(); // 显示进度对话框 &#125; @Override protected Integer doInBackground(String... params) &#123; try &#123; while(true)&#123; int downloadPercent = doDownload(); publishProgress(downloadPercent); if(downloadPercent&gt;=100)&#123; break; &#125; &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); return false; &#125; return true; &#125; // 获取当前下载进度 @Override protected void onProgressUpdate(Integer... values) &#123; progressDialog.setMessage(\"下载进度\"+values[0]+\"%\"); &#125; // 处理执行结果 @Override protected void onPostExecute(Integer status) &#123; progressDialog.dismiss(); // 关闭进度对话框 // 提示下载结果 if(result)&#123; Toast.makeText(context, \"下载成功\", Toast.LENGTH_SHORT).show(); &#125; else &#123; Toast.makeText(context, \"下载失败\", Toast.LENGTH_SHORT).show(); &#125; &#125;&#125;","tags":[{"name":"多线程编程","slug":"多线程编程","permalink":"http://yoursite.com/tags/多线程编程/"}]},{"title":"启动同一应用中带返回值的另一个 Activity","date":"2017-05-19T12:05:16.549Z","path":"2017/05/19/启动同一应用中带返回值的另一个 Activity/","text":"通常在启动 带返回值的 Activity 时，我们使用 StartActivityForResult() 方法，然后通过 Intent 传递意图和数据，但是对于在同一应用中的 子 Activity 要调用 父 Acitivity 并返回数据给 父 Activity 时，可利用 Activity 的启动模式和 Intent 的Flag 来实现数据的传递。 注意： StartActivityForResult() 的方式更适合不同应用之间通信。 具体应用场景中如下图 在任务栈中，我们启动了 MainActivity 、Activity A 、SecondActivity 、Activity B ，现在需要在 SecondActivity 中启动 MainActivity ，并返回数据给 MainActivity ，具体做法如下： 1. 在 AndroidManifest 文件中将 MainActivity 的 launchMode 属性设置为 SingleTop 12&lt;activity android:name=\".MainActivity\" android:launchMode=\"singleTop\"&gt; 2. 在 SecondActivity 中启动 MainActivity ，并传递数据 1234Intent intent = new Intent(this, MainActivity.class); intent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); intent.putExtra(\"second_data\", \"Hello MainActivity\"); startActivity(intent); 3. 在 MainActivity 中接收数据 接收数据具体为重写 onNewIntent() 方法 12345@Overrideprotected void onNewIntent(Intent intent) &#123; super.onNewIntent(intent); String str = intent.getStringExtra(\"second_data\");&#125; 具体过程分析：SecondActivity 启动 MainActivity 时，给 Intent 设置 FLAG_ACTIVITY_CLEAR_TOP Flag，FLAG_ACTIVITY_CLEAR_TOP 的具体用法为：启动目标 Activity 时，目标 Activity 的 launchMode 属性为默认，或者设置为 standard 时，目标 Activity 会和目标 Activity 之上的所有 Activity 一起被销毁，然后创建目标 Activity 的新实例，这里我们将目标 Activity 的 launchMode 设置为 singleTop 就能保证当前的目标 Activity 实例不被销毁，同时使用 onNewIntent() 接收传递的数据。","tags":[{"name":"Activity启动模式","slug":"Activity启动模式","permalink":"http://yoursite.com/tags/Activity启动模式/"}]},{"title":"Fragment 初步学习总结","date":"2017-05-19T12:05:16.546Z","path":"2017/05/19/Fragment 初步学习总结/","text":"Fragment 在 Android 3.0 开始引入，主要用来解决兼容平板的问题，只开发一个应用解决平板和手机上的不同布局，合理利用屏幕空间。 一、 Fragment 的两种加载模式1、静态加载模式(1) 首先创建一个 left_fragment.xml ，用来展示 Fragment 的布局。 123456789101112&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;Button android:id=\"@+id/button1\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:text=\"Button 1\"/&gt;&lt;/LinearLayout&gt; (2) 然后创建一个 LeftFragment.java 类，用来处理 Fragment 中的逻辑。 12345678public class LeftFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.left_fragment, container, false); return view; &#125;&#125; (3) 最后在 activity.xml 中加入 &lt;fragment&gt; 标签。 12345&lt;fragment android:id=\"@+id/left_fragment\" android:name=\"com.example.fragmenttest.LeftFragment\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" /&gt; 2、动态加载模式对于动态加载 Fragment ，采用 &lt;FramLayout&gt; 布局来动态加载不同的 &lt;fragment&gt; 布局，具体如下： (1)创建两个 fragment 布局，分别为 right_fragment.xml 和 another_right_fragment.xml right_fragment.xml1234567891011121314&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:background=\"#00ff00\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_horizontal\" android:textSize=\"30sp\" android:text=\"This is RightFragment\"/&gt;&lt;/LinearLayout&gt; another_right_fragment.xml1234567891011121314&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" android:background=\"#ffff00\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center_horizontal\" android:textSize=\"30sp\" android:text=\"This is anotherFragment\"/&gt;&lt;/LinearLayout&gt; (2)创建 RightFragment.java 类和 AnotherRightFragment.java 类12345678public class RightFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.right_fragment, container, false); return view; &#125;&#125; 12345678public class AnotherRightFragment extends Fragment &#123; @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) &#123; View view = inflater.inflate(R.layout.another_right_fragment, container, false); return view; &#125;&#125; (3)为了在平板中加载不同的 activity_main.xml 文件，我们需要在重新创建一个文件件用来专门存放加载平板的 activity_main.xml文件，具体为在 res 文件夹下新建 layout-large 文件夹，在 layout-large 下创建 activity_main.xml 123456789101112131415161718&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\"&gt; &lt;fragment android:id=\"@+id/left_fragment\" android:name=\"com.example.fragmenttest.LeftFragment\" android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:layout_weight=\"1\" /&gt; &lt;FrameLayout android:id=\"@+id/right_layout\" android:layout_width=\"0dp\" android:layout_height=\"match_parent\" android:layout_weight=\"3\" /&gt;&lt;/LinearLayout&gt; (4)在 MainActivity.java 类中处理动态加载的逻辑 1234567891011121314151617181920//MainActivity 实现 OnClickListener 接口@Overridepublic void onClick(View view) &#123; switch (view.getId()) &#123; case R.id.button1: replaceFragment(new RightFragment()); break; case R.id.button2: replaceFragment(new AnotherRightFragment()); break; &#125;&#125;private void replaceFragment(Fragment fragment) &#123; FragmentManager fragmentManager = getFragmentManager(); FragmentTransaction transaction = fragmentManager.beginTransaction(); transaction.replace(R.id.right_layout, fragment); transaction.addToBackStack(null); transaction.commit();&#125; 其中使用到了 FragmentManager 和 FragmentTransaction 类 在 Android 3.0 之后使用 getFragmentManager() 获得FragmentManager 对象 FragmentTransaction 用来处理 Fragment 的动态加载事务，包含 show() 、 hide() 、add() 、 replace() 、remove() 、 commit() 等方法。 addToBackStack() 模拟返回栈，按 Back 键不会直接退出当前 Activity，而是返回上一 Fragment 。","tags":[{"name":"Android基础","slug":"Android基础","permalink":"http://yoursite.com/tags/Android基础/"}]},{"title":"Broadcast 初步学习","date":"2017-05-19T12:05:16.542Z","path":"2017/05/19/Broadcast 初步学习/","text":"Broadcast 的分类1. 普通广播（异步方式，同一时刻所有接收者都有可能接收到广播）2. 有序广播（按照顺序接收广播，优先级高的接收者先接收，并且可以截 断广播，优先级低的接收者就不能接收到广播） Broadcast 的注册方式1. 静态注册（在 AndroidManifest.xml 文件中注册）2. 动态注册（在代码中注册，必须取消注册才行） 在程序内可以接收系统的广播，同时 Broadcast 可以跨应用传递，如果只定义在本应用内使用，可以使用 本地广播广播的传递通过 Intent 发送和接收自定义广播###1. 普通广播静态注册方式 首先，创建一个 MyBroadcastReceiver 类继承 BroadcastReceiver，这个类是广播接收者，用于事件处理，重写 onReceive()方法即可123456public class MyBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, \"自定义普通广播静态注册\", Toast.LENGTH_SHORT).show(); &#125;&#125; 然后，在 AndroidManifest.xml 文件中注册广播12345&lt;receiver android:name=\".MyBroadcastReceiver\"&gt; &lt;intent-filter android:priority=\"100\"&gt; &lt;action android:name=\"com.example.broadcasttest.MY_BROADCAST\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 最后，在需要发送广播的地方发送相应的广播12Intent intent = new Intent(\"com.example.broadcasttest.MY_BROADCAST\");sendBroadcast(intent); 动态注册方式动态注册广播使用的是内部类的方式 首先，创建内部类 MyBroadcastReceiver 继承 BroadcastReceiver123456class MyBroadcastReceiver extends BroadcastReceiver &#123; @Override public void onReceive(Context context, Intent intent) &#123; Toast.makeText(context, \"自定义普通广播动态注册\", Toast.LENGTH_SHORT).show(); &#125;&#125; 然后，在注册广播12345678910MyBroadcastReceiver receiver; @Overrideprotected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); IntentFilter intentFilter=new IntentFilter(\"com.example.testbroadcast.SEND_BROADCAST\"); receiver = new MyBroadcastReceiver(); // 注册广播 registerReceiver(receiver,intentFilter); &#125; 并且不能忘记取消注册123456@Overrideprotected void onDestroy() &#123; super.onDestroy(); // 取消注册 unregisterReceiver(receiver);&#125; 发送广播12Intent intent = new Intent(\"com.example.testbroadcast.SEND_BROADCAST\"); sendBroadcast(intent); ###2. 有序广播注意事项：有序广播需要给广播接收者设置优先级，在动态方式中通过1intentFilter.setPriority(100); 在静态方式中通过 intent-filter 标签的属性 priority 来设置1&lt;intent-filter android:priority=\"100\"&gt; 有序广播的截断在优先级高的广播接收者中使用1abortBroadcast(); ###3. 本地广播本地广播和普通广播还有有序广播的区别在于，使用了 LocalBroadcastManager 来管理接收者，使用内部类的方式 注册接收者12345678910private MyBroadcastReceiver receiver;private LocalBroadcastManager localBroadcastManager;@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); localBroadcastManager = LocalBroadcastManager.getInstance(this); intentFilter = new IntentFilter(\"com.example.broadcasttest.SEND_BROADCAST\"); receiver = new LocalBroadcastReceiver(); localBroadcastManager.registerReceiver(receiver, intentFilter); 取消注册12345@Overrideprotected void onDestroy() &#123; super.onDestroy(); localBroadcastManager.unregisterReceiver(localBroadcastReceiver);&#125; 发送广播12Intent intent=new Intent(\"com.example.broadcasttest.LOCAL_BROADCAST\");localBroadcastManager.sendBroadcast(intent);","tags":[{"name":"Android基础","slug":"Android基础","permalink":"http://yoursite.com/tags/Android基础/"}]},{"title":"Android 数据持久化","date":"2017-05-19T12:05:16.539Z","path":"2017/05/19/Android 数据持久化/","text":"Android 数据持久化分类： SharedPerfences 存储 文件存储 SQLite 数据库存储 以上不同方式的数据持久化方案根据应用场景的不同，各有优缺点，以下对不同类别的存储方式进行对比： 1. SharedPerfences 存储SharedPerfences 存储是 Android 中最常见的存储方式，快捷方便，以键值对的方式存储为 xml 格式的文件 SharedPerfences 存储数据的三大步骤：① 获得一个 SharedPerfences 对象（有三种方式） Context 类中的 getSharedPreferences() 方法 123// 参数1：存储数据的文件名，文件被存储在 /data/data/&lt;packagename&gt;/shared_prefs/ 目录下// 参数2：用于指定操作模式SharedPreferences sp = getSharedPreferences(\"data\", MODE_PRIVATE); Activity 类中的 getPreferences() 方法 12// 只接收一个操作模式参数，使用当前 Activity 的类名作为文件名SharedPreferences sp = getPreferences(MODE_PRIVATE); PreferenceManager 类中的 getSharedPreferenes() 方法（静态方法） 12// 接收一个 Context 参数，使用当前应用程序的包名作为文件名 SharedPreferences sp = PreferenceManager.getDefaultSharedPreferences(this); ② 调用 SharedPreferences 对象的 edit() 方法获取一个 SharedPreferences.Editor 对象。③ 向 SharedPreferences.Editor 对象中添加数据，通过调用 getXXX() 方法。④ 调用 Editor 对象的 commit() 方法，完成数据存储操作。 存数据12345678public void saveData(View view) &#123; SharedPreferences.Editor editor = getSharedPreferences(\"data\", MODE_PRIVATE).edit(); editor.putString(\"name\", \"Tom\"); editor.putInt(\"age\", 20); editor.putBoolean(\"married\", false); editor.commit(); Toast.makeText(this, \"保存成功\", Toast.LENGTH_SHORT).show();&#125; 读数据123456789public void getData(View view) &#123; SharedPreferences sp = getSharedPreferences(\"data\", MODE_PRIVATE); String name = sp.getString(\"name\", \"null\"); int age = sp.getInt(\"age\", 0); boolean married = sp.getBoolean(\"married\", false); Log.d(TAG, name); Log.d(TAG, age + \"\"); Log.d(TAG, married + \"\");&#125; 2. 文件存储文件存储分为内存储（Internal） 和 外存储（External），内存储指的是将文件存储在系统内存中，而外存储指的是将文件存储在 SD 卡中，文件存储采用流的方式。 内存储特点： 不需要声明权限 只能在 APP 内部访问 APP 被卸载，文件被移除 内存储保存文件，默认保存在 /data/data/&lt;packagename&gt;/files目录下，使用 openFileOutput() 方法创建一个文件，并返回一个 FileOutputStream 对象，对文件进行数据存储操作 保存文件到内部存储空间1234567891011121314151617181920private void saveFile(String inputText) &#123; FileOutputStream out; BufferedWriter writer = null; try &#123; // openFileOutput() 第一个参数为文件名，第二个参数指定操作文件的类型 out = openFileOutput(\"data\", Context.MODE_PRIVATE); writer = new BufferedWriter(newOutputStreamWriter(out)); writer.write(inputText); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if (writer != null) &#123; writer.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 从内部存储空间读取文件 读取数据依据 openFileInput() 方法，返回一个 FileInputStream 对象123456789101112131415161718192021222324private String load() &#123; FileInputStream in; BufferedReader reader = null; StringBuilder content = new StringBuilder(); try &#123; in = openFileInput(\"data\"); reader = new BufferedReader(new InputStreamReader(in)); String line = \"\"; while ((line = reader.readLine()) != null) &#123; content.append(line); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; return content.toString();&#125; 外存储特点： 所有 APP 都可以访问 需要声明权限 设置权限12&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt;&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /&gt; 保存文件到外部存储空间1234567891011121314151617181920212223public void save2External(View view) &#123; String inputText = medit.getText().toString(); FileOutputStream out = null; BufferedWriter writer = null; try &#123; File dir = getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS); File file = new File(dir,\"data.txt\"); out=new FileOutputStream(file); writer=new BufferedWriter(new OutputStreamWriter(out)); writer.write(inputText); Toast.makeText(this, \"保存至SD卡成功\", Toast.LENGTH_SHORT).show(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if (writer != null) &#123; try &#123; writer.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 从外部存储空间读取文件123456789101112131415161718192021222324252627282930313233public void read4External(View view) &#123; FileInputStream in = null; BufferedReader reader = null; StringBuilder content = new StringBuilder(); try &#123; File dir = getExternalFilesDir(Environment.DIRECTORY_DOWNLOADS); File file=new File(dir,\"data.txt\"); in=new FileInputStream(file); reader = new BufferedReader(new InputStreamReader(in)); String line = \"\"; while ((line = reader.readLine()) != null) &#123; content.append(line); &#125; String fileContent = content.toString(); if (!TextUtils.isEmpty(fileContent)) &#123; medit.setText(fileContent); medit.setSelection(fileContent.length()); Toast.makeText(this, \"从SD卡读取成功\", Toast.LENGTH_SHORT).show(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; if (reader != null) &#123; try &#123; reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 3. SQLite 数据库存储SQLite 是嵌入到 Android 系统中的轻量型数据库，SQLite 提供了 SQLiteOpenHelper 帮助类来操作数据库的 创建 和 升级 等操作， SQLiteOpenHelper 是一个抽象类，提供了 onCreate() 和 onUpgrade() 两个方法，由于创建和升级数据库。 创建数据库创建的数据库会保存在 /data/data/&lt;package name&gt;/databases/ 目录下 首先创建 MyDatabaseHelper 类继承 SQLiteOpenHelper ，并在 onCreate() 方法中创建数表，这样在创建数库的时候数据表被一起创建12345678910111213141516171819202122public class MyDatabaseHelper extends SQLiteOpenHelper &#123; private Context mContext; public static final String CREATE_BOOK = \"create table Book (\" + \"id integer primary key autoincrement,\" + \"author text,\" + \"price real,\" + \"pages integer)\"; public MyDatabaseHelper(Context context, String name, SQLiteDatabase.CursorFactory factory, int version) &#123; super(context, name, factory, version); mContext = context; &#125; @Override public void onCreate(SQLiteDatabase sqLiteDatabase) &#123; sqLiteDatabase.execSQL(CREATE_BOOK); Toast.makeText(mContext, \"创建成功\", Toast.LENGTH_SHORT).show(); &#125; @Override public void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) &#123;&#125; 然后在 MainActivity 中的 Button 点击事件中调用 getWritableDatabase() 方法，来创建数据库123456789101112131415161718public class MainActivity extends AppCompatActivity &#123; private MyDatabaseHelper dbHelper; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 参数说明: // 1. Context // 2. 数据库文件名 // 3. 查询时返回一个自定义的 Cursor，一般设置为 null // 4. 数据库版本号，版本号发生变化会回调 onUpgrade() 方法 dbHelper = new MyDatabaseHelper(this, \"BookStore.db\", null, 1); &#125; public void createDatabase(View view) &#123; dbHelper.getWritableDatabase(); &#125;&#125; 升级数据库当数据版本发生变化时，onUpgrade() 方法会被回调，在 onUpgrade() 执行数据库更新的操作 12// 数据库版本发生变化new MyDatabaseHelper(this, \"BookStore.db\", null, 3); onUpgrade() 中的逻辑1234567891011121314151617public static final String CREATE_CATEGORY = \"create table Catagory (\" + \"id integer primary key autoincrement,\" + \"category_name text,\" + \"category_code integer)\"; @Overridepublic void onUpgrade(SQLiteDatabase sqLiteDatabase, int oldVersion, int newVersion) &#123; // 注意switch语句没有break,保证数据库永远是最新的 switch (oldVersion) &#123; // 添加新的表Catagory case 1: sqLiteDatabase.execSQL(CREATE_CATEGORY); // 给表 Book 添加 category_id 列 case 2: sqLiteDatabase.execSQL(\"alter table Book add category_id integer\"); &#125;&#125; 对数据表的 CRUD 操作C (Create)：添加R (Retrieve)：查询U (Update)：更新D (Delete)：删除 添加数据1. 使用 Android 提供的辅助性方法实现 调用 SQLiteOpenHelper 的 getReadableDatabase() 或 getWritableDatabase() 方法可以创建数据库，并且返回一个 SQLiteDatabase 对象，通过这个对象可以对数据进行 CRUD 操作123456789101112131415public void addData(View view) &#123; SQLiteDatabase database = dbHelper.getWritableDatabase(); ContentValues values = new ContentValues(); // 添加第一条数据 values.put(\"author\", \"Dan Brown\"); values.put(\"pages\", 454); values.put(\"price\", 16.79); database.insert(\"Book\", null, values); // 添加第二条数据 values.put(\"author\", \"June\"); values.put(\"pages\", 100); values.put(\"price\", 13.33); database.insert(\"Book\", null, values);&#125; 2. 使用SQL操作数据库1database.execSQL(\"insert into Book (author,pages,price) values(?,?,?)\",new String[]&#123;\"June\",\"459\",\"9.99\"&#125;); 更新数据1. 使用 Android 提供的辅助性方法实现123456public void updateData(View view) &#123; SQLiteDatabase database = dbHelper.getWritableDatabase(); ContentValues values=new ContentValues(); values.put(\"price\", 10.99); database.update(\"Book\", values, \"author=?\", new String[]&#123;\"Dan Brown\"&#125;);&#125; 2. 使用SQL操作数据库1database.execSQL(\"updata Book set price = ? where author = ?\", new String[]&#123;\"5.99\", \"June\"&#125;); 删除数据1. 使用 Android 提供的辅助性方法实现1234public void deleteData(View view) &#123; SQLiteDatabase database = dbHelper.getWritableDatabase(); database.delete(\"Book\", \"author=?\", new String[]&#123;\"Dan Brown\"&#125;);&#125; 2. 使用SQL操作数据库1database.execSQL(\"delete from Book where pages &gt; ?\", new String[]&#123;\"300\"&#125;); 查询数据1. 使用 Android 提供的辅助性方法实现12345678910111213141516public void queryData(View view) &#123; SQLiteDatabase database = dbHelper.getWritableDatabase(); // 查询所有 Cursor cursor = database.query(\"Book\", null, null, null, null, null, null); while (cursor.moveToNext())&#123; // 遍历Cursor对象，取出数据并打印 String author = cursor.getString(cursor.getColumnIndex(\"author\")); int pages = cursor.getInt(cursor.getColumnIndex(\"pages\")); double price = cursor.getDouble(cursor.getColumnIndex(\"price\")); Log.d(TAG, author); Log.d(TAG, pages + \"\"); Log.d(TAG, price + \"\"); &#125; cursor.close();&#125; 2. 使用SQL操作数据库1Cursor cursor = database.rawQuery(\"select * from Book\", null); 事务特点：保证某一系列操作的操作要么全部完成，要么一个都不会完成。 应用事务替换数据库所有数据，中途模拟出现异常，则替换不能执行，注释异常之后，替换完成执行。123456789101112131415161718public void replaceData(View view) &#123; database = dbHelper.getWritableDatabase(); database.beginTransaction();// 开启事务 try &#123; database.delete(\"Book\", null, null); // 模拟出现异常 if (true) &#123; throw new NullPointerException(); &#125; // 写入新的数据 database.execSQL(\"insert into Book (author,pages,price) values(?,?,?)\", new String[]&#123;\"June\", \"1000\", \"25.99\"&#125;); database.setTransactionSuccessful();// 事务执行成功 &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;finally &#123; database.endTransaction();// 结束事务 &#125;&#125;","tags":[{"name":"Android基础","slug":"Android基础","permalink":"http://yoursite.com/tags/Android基础/"}]},{"title":"Android 6.0 之动态权限申请","date":"2017-05-19T12:05:16.533Z","path":"2017/05/19/Android 6.0 之动态权限申请/","text":"我们都知道 Android 中的权限在 AndroidManifest.xml 文件中配置，对于 Android 6.0 之前的 API，开发者只能将应用中可能会使用到的权限全部配置在 AndroidManifest.xml 中，然后用户在安装应用时，会有权限的提示，但是如果这个应用必须安装，并且它申请了涉及用户隐私和安全的危险权限，这样用户只能选择默默承受，但是对于 Android 6.0 及其之后的 API，开发者可以将危险权限采取动态申请的方式来配置，这样做的好处为，用户在进行某个涉及隐私或安全的操作时，系统会弹出提示框，让用户自己选择是否要申请该权限，这样便很好的控制了应用程序的安全性 。 具体操作如下： 1. 首先还是在 AndroidMnifest.xml 文件中配置所需权限1&lt;uses-permission android:name=\"android.permission.CALL_PHONE\" /&gt; 这里我们使用打电话的权限，它属于危险权限 2. 然后在 MainActivity.java 文件中添加动态申请权限的代码1234567891011121314151617181920212223242526272829303132public void makeCall(View view) &#123; if (ContextCompat.checkSelfPermission(MainActivity.this, Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) &#123; ActivityCompat.requestPermissions(MainActivity.this,new String[]&#123;Manifest.permission.CALL_PHONE&#125;,1); &#125;else &#123; call(); &#125;&#125;private void call() &#123; try &#123; Intent intent = new Intent(Intent.ACTION_CALL); intent.setData(Uri.parse(\"tel:10086\")); startActivity(intent); &#125; catch (SecurityException e) &#123; e.printStackTrace(); &#125;&#125;@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) &#123; switch (requestCode) &#123; case 1: if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) &#123; call(); &#125; else &#123; Toast.makeText(this, \"权限被拒绝\", Toast.LENGTH_SHORT).show(); &#125; break; default: &#125;&#125; 分析上面代码： 第一步判断用户是否已经授权了权限，通过 ContextCompat.checkSelfPermission() 方法。 checkSelfPermission() 传两个参数 第一是 Contenxt 第二是 具体的权限名 将返回值和 PackageManager.PERMISSION_GRANTED 比较，相等说明用户已经授权，直接执行 call() 方法即可，不等则需要向用户申请授权，通过 ActivityCompat.requestPermissions() 方法动态申请权限 requestPermissions() 传三个参数 第一是 Activity 的实例 第二是 一个 String[] 第三是 请求码（只要是唯一的值即可） 调用 requestPermissions() 后，系统会弹出一个申请权限的对话框，用户具体的选择会在 onRequestPermissionsResult() 方法中来处理，授权结果会封装在 grantResults 参数中，只需判断授权结果即可，用户同意直接调用 call() 方法，否则弹出提示框 。","tags":[{"name":"Android基础","slug":"Android基础","permalink":"http://yoursite.com/tags/Android基础/"},{"name":"动态添加权限","slug":"动态添加权限","permalink":"http://yoursite.com/tags/动态添加权限/"}]},{"title":"ContentProvider 总结","date":"2017-05-19T12:05:16.529Z","path":"2017/05/19/ContentProvider 总结/","text":"上图为 ContentProvider 的具体实现过程，Other App1 和 Other App2 分别提供了 ContentProvider 来向外界暴露数据，方便其他应用程序来访问。 对于不同的 ContentProvider 是由 ContentResolver 来进行管理的，其中 ContentResolver 中的 CRUD 方法对应不同 ContentProvider 中的 CRUD 方法，他们之间通过 URI 来进行消息的传递，ContentResolver 和 ContentProvider 之间的关系为，ContentProvider 只是提供数据的，而 ContentResolver 是将从 ContentProvider 中操作的结果返回给需要数据的应用程序。 ##具体过程如下： 1. 以查询数据为例，在 MainActivity.java 中添加如下代码1234567891011121314151617181920212223public static final String TAG = \"MainActivity\";// 此处URI与提供数据应用程序的&lt;provider&gt;属性 android:authorities 要一致public static final String URI = \"content://com.example.sqlitetest.provider/book\";// 查询数据public void queryData(View view) &#123; Uri uri = Uri.parse(URI); Cursor cursor = getContentResolver().query(uri, null, null, null, null); if (cursor != null) &#123; while (cursor.moveToNext()) &#123; String name = cursor.getString(cursor.getColumnIndex(\"name\")); String author = cursor.getString(cursor.getColumnIndex(\"author\")); int pages = cursor.getInt(cursor.getColumnIndex(\"pages\")); double price = cursor.getDouble(cursor.getColumnIndex(\"price\")); Log.d(TAG, name); Log.d(TAG, author); Log.d(TAG, pages + \"\"); Log.d(TAG, price + \"\"); &#125; cursor.close(); &#125;&#125; 2. 创建 DabaseProvider.java 继承 ContentProvider，并重写查询方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class DatabaseProvider extends ContentProvider &#123; public static final int BOOK_DIR = 0; public static final int BOOK_ITEM = 1; public static final int CATEGORY_DIR = 2; public static final int CATEGORY_ITEM = 3; public static final String AUTHORITY = \"com.example.sqlitetest.provider\"; private static UriMatcher uriMatcher; private MyDatabaseHelper dbHelper; static &#123; uriMatcher = new UriMatcher(UriMatcher.NO_MATCH); uriMatcher.addURI(AUTHORITY, \"book\", BOOK_DIR); uriMatcher.addURI(AUTHORITY, \"book/#\", BOOK_ITEM); uriMatcher.addURI(AUTHORITY, \"category\", CATEGORY_DIR); uriMatcher.addURI(AUTHORITY, \"catagory/#\", CATEGORY_ITEM); &#125; @Override public boolean onCreate() &#123; dbHelper = new MyDatabaseHelper(getContext(), \"BookStore.db\", null, 2); return true; &#125; @Nullable @Override public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) &#123; // 查询数据 SQLiteDatabase db = dbHelper.getReadableDatabase(); Cursor cursor = null; switch (uriMatcher.match(uri)) &#123; case BOOK_DIR: cursor = db.query(\"Book\", projection, selection, selectionArgs, null, null, sortOrder); break; case BOOK_ITEM: String bookId = uri.getPathSegments().get(1); cursor = db.query(\"Book\", projection, \"id = ?\", new String[]&#123;bookId&#125;, null, null, sortOrder); break; case CATEGORY_DIR: cursor = db.query(\"Category\", projection, selection, selectionArgs, null, null, sortOrder); break; case CATEGORY_ITEM: String categoryId = uri.getPathSegments().get(1); cursor = db.query(\"Category\", projection, \"id = ?\", new String[]&#123;categoryId&#125;, null, null, sortOrder); break; &#125; return cursor; &#125;&#125; 3. 最后在 AndroidMnifest.xml 中设置 &lt;provider&gt;12345&lt;provider android:name=\"com.example.sqlitetest.DatabaseProvider\" android:authorities=\"com.example.sqlitetest.provider\" android:exported=\"true\"&gt;&lt;/provider&gt;","tags":[{"name":"Android基础","slug":"Android基础","permalink":"http://yoursite.com/tags/Android基础/"}]},{"title":"Android 中的布局","date":"2017-05-19T12:05:16.524Z","path":"2017/05/19/Android 中的布局/","text":"Android 中的布局由常用的频率排序，如下表| 布局方式 | 使用频率等级 | 特点 ||:—-:|:—-:|:—-:||LinearLayout(线性布局)|5| 顺序排列，纵横两个方向，实现简单，多屏适配||RelativeLayout(相对布局)|5| 位置相对，对齐方式丰富，可以重叠，嵌套少，多屏适配||FrameLayout(帧布局)|3|可以重叠，对齐方式丰富，多屏适配||TableLayout(表格布局)|2|多行多列，规则布局，简单的多屏适配||GridLayout(网格布局)|1|多行多列，不规则布局，可跨行列，多屏适配，SDK4.0出现||AbsoluteLayout(绝对布局)|0|绝对坐标，不利于多屏适配| 由于 RelativeLayout 和 FrameLayout 没有 layout_weight 这个属性，因此 Android 团队提供了百分比布局，百分比布局对 RelativeLayout 和 FrameLayout 进行了功能的扩展。提供了 PercentRelativeLayout 和 PercentFrameLayout 两种布局 使用百分比布局注意事项：在项目 build.gradle 中添加以下依赖包123dependencies&#123; compile 'com.android.support:percent:25.2.0'&#125; 一、 LinearLayout 中注意的事项： LinearLayout 中的属性 Layout_gravity 和 gravity的区别： Layout_gravity：表示组件相对于父容器的位置 。gravity：表示组件内部内容相对于组件的位置 。 当属性 orientation=&quot;horizontal&quot; 时，只有垂直方向上的属性有效，同样的 orientation=&quot;vertical&quot; 时，只有水平方向上的属性有效 。 二、 RelativeLayout 中的属性第一类：属性值为 true 或 false|属性|说明||:—-:|:—-:||android:layout_centerHrizontal|水平居中||android:layout_centerVertical|垂直居中||android:layout_centerInparent|相对父元素完全居中||android:layout_alignParentTop|贴紧父元素的上边缘||android:layout_alignParentBottom|贴紧父元素的下边缘||android:layout_alignParentLeft|贴紧父元素的左边缘||android:layout_alignParentRight|贴紧父元素的右边缘|第二类：属性值必须为id的引用名 “@id/id-name”|属性|说明||:—-:|:—-:||android:layout_above|在某元素的上方||android:layout_below|在某元素的下方||android:layout_toLeftOf|在某元素的左方||android:layout_toRightOf|在某元素的右方||android:layout_alignTop|本元素的上边缘和某元素的上边缘对齐||android:layout_alignBottom|本元素的下边缘和某元素的下边缘对齐||android:layout_alignLeft|本元素的左边缘和某元素的左边缘对齐||android:layout_alignRight|本元素的右边缘和某元素的右边缘对齐|第三类：属性值为具体的像素值，如 30 dip，40 px|属性|说明||:—-:|:—-:||android:layout_marginTop|距离某元素上边缘的距离||android:layout_marginBottom|距离某元素下边缘的距离||android:layout_marginLeft|距离某元素左边缘的距离||android:layout_marginRight|距离某元素右边缘的距离|","tags":[{"name":"Android基础","slug":"Android基础","permalink":"http://yoursite.com/tags/Android基础/"}]},{"title":"Intent 初级","date":"2017-05-19T09:49:05.263Z","path":"2017/05/19/Intent 初级/","text":"Intent 作为 Android 中意图，可以通过 action 和 category 两个主要的标签指定想要启动的组件。Intent 分为 显式 和 隐式 。 1. 显式 Intent 启动另一个 Activity ，并传递数据在程序代码中注册，并且只能启动本应用中的其他组件，不能跨应用启动组件。 可以通过 Intent 传递参数给另一个 Activity使用 Intent 启动一个 SendActivity :123456789EditText meditText;public final static String EXTRA_MESSAGE = \"com.example.firstapp.MESSAGE\";public void StartSendActivity(View view) &#123; Intent intent = new Intent(this,SendActivity.class); String message = meditText.getText().toString(); intent.putExtra(EXTRA_MESSAGE,message); startActivity(intent);&#125; 使用 Intent 接收传递的参数：1234567TextView mtextView;private void setText() &#123; Intent intent = getIntent(); String message = intent.getStringExtra(MainActivity.EXTRA_MESSAGE); mtextView.setText(message);&#125; 2. 隐式 Intent在 Android 中隐式启动 Intent 的方式最常见，因为隐式 Intent 可以跨应用启动不同组件，包括系统提供的组件和自己编写的应用中的组件都可以被启动。 隐式 Intent 可以在 AndroidManifest.xml 和 代码 中注册 主要定义 action 和 category 标签1. 使用系统提供的 Intent常用的系统 Intent action：action代表已经定义的动作，通过 setAction()方法或在 AndroidManifest.xml 中设置 系统 Intent 对应字符串 功能 ACTION_VIEW android.intent.action.VIEW 显示指定数据/播放音乐 ACTION_DIAL android.intent.action.DIAL 打开拨号面板 ACTION_CALL android.intent.action.CALL 向指定号码打电话 ACTION_MAIN android.intent.action.MAIN 应用程序入口 ACTION_EDIT android.intent.action.EDIT 编辑指定数据 ACTION_SENDTO android.intent.action.SENDTO 发送消息 ACTION_DELETE android.intent.action.DELETE 删除数据/卸载应用 ACTION_INSERT android.intent.action.INSERT 插入数据/安装应用 同时还需要设置 category 标签：category 标签用于指定 action 被执行的环境，通过 addCategory()方法或在 AndroidManifest.xml 中设置 具体使用如下：1. 在 AndroidManifest.xml 中注册1234567&lt;activity android:name=\".SendActivity\" android:label=\"SendActivity\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.VIEW\"/&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;data android:scheme=\"http\"/&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 2. 在代码中注册启动拨号面板示例：12345public void callPhone(View view) &#123; Intent intent = new Intent(Intent.ACTION_DIAL); intent.setData(Uri.parse(\"tel:13369100203\")); startActivity(intent);&#125; 3. 使用 Intent 返回数据给上一个 Activity首先在 FirstActivity 中使用 startActivityForResult() 方法启动 SendActivity , 代码如下：1234public void playMusice(View view) &#123; Intent intent = new Intent(\"com.example.intenttest.ACTION_START\"); startActivityForResult(intent, 1);&#125; 然后在 SendActivity 中设置按钮的点击事件，使用 Intent 传递数据 ， 也可以重写返回键的 onBackPressed() 方法 ， 代码如下：1234567@Overridepublic void onBackPressed() &#123; Intent intent = new Intent(); intent.putExtra(\"data_return\", \"I'm layoutActivity\"); setResult(RESULT_OK, intent); finish();&#125; 在 FirstActivity 中重写 onActivityResult() 方法，用来接收 SendActivity 传递的数据，代码如下：12345678910@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; switch (requestCode) &#123; case 1: if (resultCode == RESULT_OK) &#123; String returnData = data.getStringExtra(\"data_return\"); Toast.makeText(this, returnData, Toast.LENGTH_SHORT).show(); &#125; &#125;&#125;","tags":[{"name":"Android基础","slug":"Android基础","permalink":"http://yoursite.com/tags/Android基础/"}]},{"title":"Android Studio 中 build.gradle文件详解","date":"2017-03-11T10:37:12.000Z","path":"2017/03/11/Android Studio 中 build.gradle文件详解/","text":"Android 项目中有两个 build.gradle 文件， 一个是在最外层目录下的， 一个是在 app 目录下的。 这两个文件对构建 Android Studio 项目都起了至关重要的作用，下面我们对这两个文件分别进行分析。 一、先来分析最外层目录下的 build.gradle 文件， 代码如下所示：1234567891011121314buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:2.3.0' &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125; 该文件中包含两个 repositories 两个闭包， 并且都声明了 jcenter() 这行配置， jcenter 是一个代码托管仓库， 通过声明了这行配置之后， 我们就可以在项目中轻松引用任何 jcenter 上的开源项目了。 其次， dependencies 闭包中使用 classpath 声明了一个 Gradle 插件， Gradle 插件并不是专门为构建 Android 项目而开发的， Java，C++ 等很多种项目都可以使用 Gradle 来构建。因此我们使用它来构建 Android 项目，则需要声明 com.android.tools.build:gradle:2.3.0 这个插件。 2.3.0 为 Gradle 插件的版本号。 二、下面我们再来看一下 app 目录下的 build.gradle 文件， 代码如下所示：1234567891011121314151617181920212223242526apply plugin: 'com.android.application'android &#123; compileSdkVersion 23 buildToolsVersion '25.0.0' defaultConfig &#123; applicationId \"com.example.administrator.myfirstapp\" minSdkVersion 19 targetSdkVersion 23 versionCode 1 versionName \"1.0\" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;dependencies &#123; compile fileTree(dir: 'libs', include: ['*.jar']) compile 'com.android.support:appcompat-v7:23.4.0' compile 'com.android.support.constraint:constraint-layout:1.0.0-beta4' testCompile 'junit:junit:4.12'&#125; 1. apply plugin：应用插件一般有两种值可选： com.android.application ：表示这是一个应用程序模块com.android.library ：表示这是一个库模块 应用程序模块和库模块的最大区别在于，一个是可以直接运行，一个只能作为代码库依附于别的应用程序模块运行。 2. android 闭包：用来配置项目构建的各种属性 compileSdkVersion ：用于指定项目的编译版本buildToolsVersion ：用于指定项目构建工具的版本 2.1 defaultConfig 子闭包：对项目的更多细节进行配置 applicationId：用于指定项目的包名minSdkVersion：用于指定项目最低兼容的 Android 系统版本targetSdkVersion：指定的值表示你在该版本上已经做过了充分的测试，系统将会为你的应用程序启用一些最新的功能和特征versionCode：用于指定项目的版本号versionName：用于指定项目的版本名 2.2 buildTypes 子闭包：用于指定生成安装文件的相关配置通常只会有两个子闭包（debug闭包是可以忽略不写的，因此我们看到上面的代码中就只有一个 release 闭包）。 debug：测试版安装文件的配置release：正式版安装文件的配置爱 minifyEnabled：用于指定是否对项目的代码进行混淆， true 表示混淆， false 表示不混淆proguardFiles：用于指定混淆时使用的规则文件 proguardFiles：中的文件proguad-android.txt：是在 Android SDK 目录下的，里面是所有项目通用的混淆规则proguard-rules.pro：是在当前项目的根目录下的，里面可以编写当前项目特有的混淆规则 3. dependencies 闭包：指定当前项目所有的依赖关系Android Studio 项目一共有3中依赖关系：本地依赖 库依赖 远程依赖本地依赖：可以对本地的 Jar 包或目录添加依赖关系库依赖：可以对项目中的库模块添加依赖关系远程依赖：可以对 jcenter 库上的开源项目添加依赖关系 compile fileTree：本地依赖声明compile：远程依赖声明compile project：库依赖","tags":[{"name":"Android基础","slug":"Android基础","permalink":"http://yoursite.com/tags/Android基础/"},{"name":"gradle","slug":"gradle","permalink":"http://yoursite.com/tags/gradle/"}]}]